
#INTERNAL USE SOFTWARE LICENSE AGREEMENT 

#THIS INTERNAL USE SOFTWARE LICENSE AGREEMENT ("AGREEMENT") GOVERNS YOUR
#("YOUR" OR "YOU") USE OF THE ACCOMPANYING SOFTWARE ("SOFTWARE") AND ALL
#DOCUMENTS RELATED TO THE SOFTWARE ("DOCUMENTATION").  BY INSTALLING OR 
#COPYING ALL OR ANY PART OF THE SOFTWARE COMPONENTS IN THIS PACKAGE, YOU 
#AGREE TO THE TERMS AND CONDITIONS OF THIS AGREEMENT.  IF YOU DO NOT AGREE 
#TO THE TERMS AND CONDITIONS OF THIS AGREEMENT, PROMPTLY RETURN THE SOFTWARE 
#TO INTEL CORPORATION ("INTEL"). IF YOU ARE AN AGENT OR EMPLOYEE OF A LEGAL 
#ENTITY, YOU REPRESENT AND WARRANT THAT YOU HAVE THE AUTHORITY TO BIND SUCH 
#LEGAL ENTITY TO THIS AGREEMENT AND THE TERMS "YOUR" AND "YOU" IN THIS 
#AGREEMENT THEN WILL REFER TO THAT LEGAL ENTITY. 


#1.		LICENSE GRANTS AND RESTRICTIONS. 

#	1.1 Software License.  
#		Subject to the terms and conditions of this Agreement, Intel grants 
#		You a personal, non-transferable, non-exclusive, worldwide, 
#		non-sublicensable limited right and license: 

#	(A) under Intel's copyrights to:

#	(1)		reproduce all or any portion of the Software solely for Your 
#			internal use for the sole purpose of performing validation 
#			activities on Your computer systems that use Intel 
#			microprocessors as the central processor; provided, however, 
#			that this license may be exercised only by Your employees and 
#			only within Your facilities; 

#	(2)		prepare derivative works of the Software for the sole purpose of 
#			performing validation activities on Your computer systems that 
#			use Intel microprocessors as the central processor; provided, 
#			however, that this license may be exercised only by Your 
#			and only within Your facilities; 

#	(3)		copy the Documentation as is reasonably necessary for You to 
#			exercise Your rights under this Section 1.1; and 

#	(B)	under Intel's Licensed Patent Claims to make copies of the Software 
#		and use the Software solely in connection with the license rights 
#		granted to You under Section 1.1, only within Your facilities and 
#		only by Your employees; provided, however, that the license under the 
#		Licensed Patent Claims does not and will not apply to any 
#		modifications to, or derivative works of, the Software, whether made 
#		by You or any third party even if the modifications and derivative 
#		works are permitted under Section 1.1.  "Licensed Patent Claims" 
#		means the claims of Intel's patents that are necessarily and directly 
#		infringed by the reproduction of the Software that is authorized in 
#		Section 1.1(A), when that Software is in its unmodified form as 
#		delivered by Intel to You and not modified or combined with anything 
#		else.  Licensed Patent Claims are only those claims that Intel can 
#		license without paying, or getting the consent of, a third party. 

#1.2	Limitations.  

#	(A)	Unless expressly permitted under Section 1.1, or unless You obtain 
#		Intel's prior express written permission, You will not and will not 
#		allow any third party to: 

#		(1)		use or copy the Software; 

#		(2)		modify, adapt, enhance, disassemble, decompile, reverse 
#				engineer, change or create derivative works from the 
#				Software; or 

#		(3)		use the Software to process the date of, or make the Software 
#				available online for the use of, third parties. 

#	(B)	The consideration under this Agreement is only for the licenses that 
#		Intel expressly grants to You in Section 1.1.  Any other rights 
#		including, but not limited to, additional patent rights, will 
#		require an additional license and additional consideration.  
#		Nothing in this Agreement requires or will be treated to require 
#		Intel to grant any additional license.  You acknowledge that an 
#		essential basis of the bargain in this Agreement is that Intel 
#		grants you no licenses or other rights including, but not limited 
#		to, patent, copyright, trademark, trade name, service mark or other 
#		intellectual property licenses or rights with respect to the Software 
#		and Documentation, by implication, estoppel or otherwise, except for 
#		the licenses expressly granted in Section 1.1.  Specifically, except 
#		for the licenses expressly granted to You in Section 1.1, Intel 
#		grants no licenses or other rights, expressly or by implication, 
#		estoppel or otherwise, to: 

#		(1)	make, use, sell, offer for sale, or import modifications of the 
#			Software; 
#		(2)	sell or offer to sell the Software; 
#		(3)	combine the Software or modified versions of the Software with 
#			other items or to use any such combination; or 
#		(4)	any claims of any patents, patent applications, or other patent 
#			rights of Intel other than the Licensed Patent Claims.  

#	(C)	You acknowledge that there are significant uses of the Software in 
#		its original, unmodified and uncombined form.  The consideration for 
#		the license in this Agreement reflects Intel's continuing right to 
#		assert patent claims against any modifications or derivative works 
#		(including without limitation, error corrections and bug fixes) of, 
#		or combinations with, the Software that You or third parties make 
#		that infringe any Intel patent claim.  

#	(D)	Except as expressly permitted under Section 1.1, You will not allow 
#		the Software or Documentation to be accessed or used by third parties 
#		or anyone other than Your employees whose duties require access or use.

#2.		OPEN SOURCE SOFTWARE.  The Software includes Open Source Software that 
#		is licensed under the applicable Open Source Software license 
#		agreement identified in the Open Source Software comments in the 
#		applicable Source Code file(s) and File Header provided with the 
#		Software.  Where applicable, the Documentation may contain additional 
#		detail.  With respect to the Open Source Software, nothing in this 
#		Agreement limits any rights under, or grants rights that supersede, 
#		the terms of the applicable Open Source Software license agreement.  
#		You will not subject the Software or Documentation, in whole or in 
#		part, to any license obligations associated with Open Source Software 
#		in a manner that subjects Intel, or any portion of the Software, to any 
#		license obligations of the Open Source Software.  

#3.		OWNERSHIP.

#	3.1		Software and Documentation.  All rights, title and interest in 
#			and to the Software and Documentation, including all copies 
#			thereof, are and will remain the exclusive property of Intel or 
#			its suppliers or licensors.  The Software is copyrighted and 
#			protected by the laws of the United States and other countries, 
#			and international treaty provisions. You may not remove any 
#			copyright notices from the Software.

#	3.2		Derivative Works.  Intel will own all copyrights in derivative 
#			works.  You irrevocably transfer and assign to Intel in 
#			perpetuity all worldwide copyrights (including, but not 
#			limited to, applications for registration of those rights and 
#			all priority rights under applicable international conventions 
#			for the protection of those rights) in the derivative works that 
#			You may have, as and when those rights arise.  You will maintain 
#			and protect Intel's copyrights in the derivative works including, 
#			but not limited to, executing any documents that Intel reasonably 
#			considers necessary for that purpose.  Intel will have the sole 
#			and unlimited right to reproduce, publish and display the 
#			derivative works, in whole or in part, or combine the 
#			derivative works with other matter or not use the derivative 
#			works at all. 

#	3.3		Feedback.  To the extent You provide Intel with Feedback, You 
#			grant to Intel and Intel accepts, a worldwide, non-exclusive, 
#			perpetual, irrevocable, royalty-free, transferable license, 
#			with the right to sublicense, under Your intellectual property 
#			rights to the Feedback to incorporate or otherwise use Feedback 
#			as provided by You to Intel.  "Feedback" means Your requirements, 
#			inputs, comments, responses, opinions, feedback and errata, 
#			whether oral or written, concerning the Software and 
#			Documentation and Your technical system requirements for Intel to 
#			include in the Software definition, design or validation.  This 
#			Section 3.3 will survive any termination of this Agreement.

#4.		CONFIDENTIALITY.  The Software and Documentation contain confidential and 
#		proprietary information of Intel and, together with the terms and 
#		conditions of this Agreement and any other confidential information 
#		disclosed in the course of performance of this Agreement, are subject to 
#		the applicable Corporate Non-Disclosure Agreement between You and Intel (
#		"CNDA"), or such other non-disclosure agreement as may be agreed to by 
#		the parties.  

#5.		NO SUPPORT.  Intel has no obligation to maintain or support the Software 
#		or Documentation.  

#6.		DISCLAIMER OF WARRANTY.  The Software is provided "AS IS" with no 
#		warranties of any kind, whether written, oral, implied or statutory, 
#		including warranties of merchantability or fitness for a particular 
#		purpose, non-infringement or arising from course of dealing or usage in 
#		trade.   

#7.		LIMITATION OF LIABILITY.  Intel and its suppliers shall not be liable for 
#		any property damage, personal injury, loss of profits, loss of use, 
#		interruption of business, or for any other special, consequential, 
#		punitive or incidental damages, however caused, whether for breach of 
#		warranty, contract, tort, negligence, strict liability or otherwise, 
#		irrespective of whether Intel has advance notice of the possibility of 
#		such damages.  

#8.		TERMINATION.  Intel may terminate this Agreement, including the licenses 
#		granted in Section 1.1, at any time upon notice to You.  Upon 
#		termination, You will immediately destroy the Software or return all 
#		copies of the Software to Intel along with any copies You have made.  You 
#		may terminate this Agreement at any time upon notice to Intel and 
#		destroying the Software, or returning the Software to Intel.  

#9.		ASSIGNMENT.  Except as expressly permitted under Section 1.1, You may not:
#		(A) delegate, assign or transfer this Agreement, or any of Your rights 
#		and obligations under this Agreement, or (B) sublicense, assign or 
#		transfer all or any part of the Software, Documentation or Confidential 
#		Information, to any third party temporarily (such as loaning, rental, 
#		licensing or timeshare) or permanently, whether by contract, operation of 
#		law, acquisition, merger, consolidation, sale of all or substantially all 
#		of Your outstanding shares or assets, other changes in control, or any 
#		other event, without the prior written consent of Intel in each instance, 
#		which consent Intel may withhold in its sole discretion.  Any attempted 
#		assignment, transfer, or sublicense that is not expressly permitted under 
#		Section 1.1 or is without consent will be a material breach of this 
#		Agreement and will be null and void.  Subject to the provisions of this 
#		Section, this Agreement will bind and inure to the benefit of the parties 
#		and their permitted successors and assigns.  

#10.	U.S. GOVERNMENT RIGHTS.  The technical data and computer software 
#		covered by this Agreement is a "Commercial Item," as such term is 
#		defined by the FAR 2.101 (48 C.F.R. 2.101) and is "commercial 
#		computer software" and "commercial computer software documentation" 
#		as specified under FAR 12.212 (48 C.F.R. 12.212) or DFARS 227.7202 
#		(48 C.F.R. 227.7202), as applicable.  This commercial computer 
#		software and related documentation is provided to end users for use, 
#		by and on behalf of the U.S. Government, with only those rights as 
#		are granted to all other end users pursuant to the terms and 
#		conditions herein.  Use for or on behalf of the U.S. Government is 
#		permitted only if the party acquiring or using this software is 
#		properly authorized by an appropriate U.S. Government official.  This 
#		use by or for the U.S. Government clause is in lieu of, and 
#		supersedes, any other FAR, DFARS, or other provision that addresses 
#		Government rights in the Software covered by this Agreement.

#11.	EXPORT LAWS.  You will not export, either directly or indirectly, 
#		any product, service or technical data or system incorporating the 
#		Software without first obtaining any required license or other 
#		approval from the U. S. Department of Commerce or any other agency or 
#		department of the United States Government.  In the event any product 
#		is exported from the United States or re-exported from a foreign 
#		destination by You, You shall ensure that the distribution and 
#		export/re-export or import of the product is in compliance with all 
#		laws, regulations, orders, or other restrictions of the U.S. Export 
#		Administration Regulations and the appropriate foreign government.  
#		You agree that neither You nor any of Your subsidiaries will 
#		export/re-export any technical data, process, product, or service, 
#		directly or indirectly, to any country for which the United States 
#		government or any agency thereof or the foreign government from where 
#		it is shipping requires an export license, or other governmental 
#		approval, without first obtaining such license or approval.

#12.	GOVERNING LAW.  All disputes arising out of or related to this 
#		Agreement, whether based on contract, tort, or any other legal or 
#		equitable theory, will in all respects be governed by, and construed 
#		and interpreted under, the laws of the United States of America and 
#		the State of Delaware, without reference to conflicts of laws 
#		principles.  The parties agree that the United Nations Convention on 
#		Contracts for the International Sale of Goods (1980) is specifically 
#		excluded from and will not apply to this Agreement. 

#13.	ENTIRE AGREEMENT.  This Agreement contains the complete and exclusive 
#		agreement and understanding between the parties concerning the 
#		subject matter of this Agreement, and supersedes all prior and 
#		contemporaneous proposals, agreements, understandings, negotiations, 
#		representations, warranties, conditions, and communications, oral or 
#		written, between the parties relating to the subject matter.  This 
#		Agreement, including without limitation, its termination, has no 
#		effect on any signed non-disclosure agreements between the parties, 
#		which remain in full force and effect as separate agreements 
#		according to their terms.  No modification or amendment to this 
#		Agreement will be effective unless in writing and signed by 
#		authorized representatives of each party.  


#%!/usr/bin/env python
"""
    Module: mcd.py

    Package Dependency: None
    Description: 
        This is a standalone MCA(Machine Check Architecture) decoder.
        Users could run the script as 1) manual decoding; or 2) pass in command line parameters.
        Please see the usage instruction document in the same script folder.

    Autor: Jerr Chen
    Date: August 14, 2014
"""

import textwrap as _textwrap
import sys

_revString = '2014.08.12 - HSX' 
_decodeList = [
{'bankType':'IFU', 'fieldMask':0x00000000000f0000,'AndMask':0x0000000000000005,'OrMask':0xffffffffffff0005,'genDesc':'IFU Internal Parity Error','decode':{0: ['Register File Parity Error ', 'Register file buffer reported machine check. Errors of this type can be silicon related (we may see this on earlier steppings of parts) but are generally not expected in production stages of the development cycle.  Steps should be taken to isolate the failure to a specific part. Test for sensitivities to voltage, frequency and temperature. In a properly functioning part an effort of this kind can manifest itself by operating the part out of specified tolerances. The most common occurrence of an issue of this type is power delivery to the cpu core. This area is powered by the core voltage pins. In the non compounded case, this error is expected to assert the MCERR# variant of the error. '], 1: ['DSB Parity Errors', 'Data sequencer buffer parity error. Errors of this type can be silicon related (we may see this on earlier steppings of parts) but are generally not expected in production stages of the development cycle.  Steps should be taken to isolate the failure to a specific part. Test for sensitivities to voltage, frequency and temperature. The most common occurrence of an issue of this type is power delivery to the cpu core. This area is powered by the core voltage pins. In the non compounded case, this error is expected to assert the MCERR# variant of the error. '], 2: ['MS uRAM Parity Error', 'Micro sequencer uRam parity error. Errors of this type can be silicon related (we may see this on earlier steppings of parts) but are generally not expected in production stages of the development cycle.  Steps should be taken to isolate the failure to a specific part. Test for sensitivities to voltage, frequency and temperature. The most common occurrence of an issue of this type is power delivery to the cpu core. This area is powered by the core voltage pins.  In the non compounded case, this error is expected to assert the MCERR# variant of the error. '], 3: ['Instruction Queue Parity Error ', 'Instruction queue parity error. Errors of this type can be silicon related (we may see this on earlier steppings of parts) but are generally not expected in production stages of the development cycle.  Steps should be taken to isolate the failure to a specific part. Test for sensitivities to voltage, frequency and temperature. The most common occurrence of an issue of this type is power delivery to the cpu core. This area is powered by the core voltage pins.  In the non compounded case, this error is expected to assert the MCERR# variant of the error. '], 4: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 5: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 6: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 7: ['Instruction Decode Queue Parity Error  ', ''], 8: ['Branch Array Parity Error   ', ''], 9: ['MS Unique ROM Parity Error', ''], 10: ['MS Pointer ROM Parity Hard Error', ''], 11: ['MS Pointer ROM Parity Recoverable Error', ''], 12: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 13: ['Undefined Encoding', 'Undefined encoding'], 14: ['Undefined Encoding', 'Undefined encoding'], 15: ['Inclusion Error', 'Operation violates the inclusion property of the cache structures.  The requested instruction is no longer in the cache domain (which is what the inclusion property implies).  An error of this type is likely core voltage related or a specific part failure. ']}},
{'bankType':'IFU', 'fieldMask':0x00000000000f0000,'AndMask':0x0000000000000100,'OrMask':0xffffffffffff01f0,'genDesc':'IFU Parity Error    ','decode':{0: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 1: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 2: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 3: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 4: ['ICache Data Parity Error ', 'Poison signature in the IFU. This implies the data received by the IFU was inverted as part of a poison event. The origin of the error is elsewhere.  Check for poison forwarding mode and other MCA Status banks. In a poison enabled failure case, the source of the error should have logged a corrected error. This implies that the MCA bank logs may not be sufficient given there is a time element to this. The originating failure will have been logged and signaled via CMCI. The operating system should contain logs of this source stream.   The most common occurrence of an issue of this type is power delivery to the cpu core. This area is powered by the core voltage pins.'], 5: ['ICache Tag Parity Error', 'Icache tag parity error. This type of error should be a very rare event under normal operating conditions.   If this error is repeatable in any domain, it is likely core voltage related or a specific part failure.  The most common occurrence of an issue of this type is power delivery to the cpu core. This area is powered by the core voltage pins. Further data collection is necessary to understand the environment where the failure occurs.'], 6: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 7: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 8: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 9: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 10: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 11: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 12: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 13: ['Undefined Encoding', 'Undefined encoding'], 14: ['Undefined Encoding', 'Undefined encoding'], 15: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod']}},
{'bankType':'IFU', 'fieldMask':0x00000000000f0000,'AndMask':0x0000000000000010,'OrMask':0xffffffffffff0010,'genDesc':'ITLB Parity Error   ','decode':{0: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 1: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 2: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 3: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 4: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 5: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 6: ['ITLB Linear or Physical Parity Errors', 'ITLB parity error.  This type of error should be a very rare event in normal operating conditions.  If this error is repeatable in any domain, is likely core voltage related or a specific part failure.  Please take steps to isolate the problem to a specific part or system. Gathering further information on the failure environment may also  be useful [Power management dependency for instance].'], 7: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 8: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 9: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 10: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 11: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 12: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 13: ['Undefined Encoding', 'Undefined encoding'], 14: ['Undefined Encoding', 'Undefined encoding'], 15: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod']}},
{'bankType':'IFU', 'fieldMask':0x00000000000f0000,'AndMask':0x0000000000000406,'OrMask':0xffffffffffff0406,'genDesc':'Internal Control Flow Errors','decode':{0: ['Ucode Trusted Paths Error', 'Microcode control flow error'], 1: ['Undefined Encoding', ''], 2: ['Patch RAM Protection Trusted Paths Error', 'Microcode update control flow error'], 3: ['Undefined Encoding ', ''], 4: ['C6 SRAM Protection Trusted Paths Error', 'Illegal access error'], 5: ['Undefined Encoding', '']}},
{'bankType':'DCU', 'fieldMask':0x0000000000200000,'AndMask':0x0000000000200401,'OrMask':0xffffffffff200401,'genDesc':'DCU APIC Error      ','decode':{0: ['Reserved', 'Reserved Encoding'], 1: ['APIC Error', 'An error was detected and the address range was in the APIC region. A common error of this type is related to incorrect cachebility type for the APIC region. Check to see the mapping of the APIC region is correct (uncacheable).']}},
{'bankType':'DCU', 'fieldMask':0x0000000000200000,'AndMask':0x0000000000000104,'OrMask':0xffffffffffef01f4,'genDesc':'DCU Parity Error    ','decode':{0: ['DCU Parity Error', ''], 1: ['APIC Error', 'An error was detected and the address range was in the APIC region. A common error of this type is related to incorrect cachebility type for the APIC region. Check to see the mapping of the APIC region is correct (uncacheable).']}},
{'bankType':'DCU', 'fieldMask':0x0000000000100000,'AndMask':0x0000000000100174,'OrMask':0xffffffffff100174,'genDesc':'DCU Parity Error    ','decode':{0: ['Reserved', 'Reserved Encoding'], 1: ['WBINVD Error', 'This error code represents a data error WBINV cycle. This is not a software generated event.  The error is uncorrectable but in some cases the escalation may (poison enabled) be deferred or delayed. In any event, the cause of the failure is likely to be related to power delivery to the cores. The implication is that this error can appear as an MCE or as a CMCI event. One can check for the condition based on the UC, PCC, S and AR bits of MCi_STATUS to understand which variant of the error escalation flow this is logged in.']}},
{'bankType':'DCU', 'fieldMask':0x0000000000100000,'AndMask':0x0000000000100134,'OrMask':0xffffffffff100134,'genDesc':'DCU Parity Error    ','decode':{0: ['Reserved', 'Reserved Encoding'], 1: ['Poison Error', 'An uncorrected error has been detected on a DCU cycle (see MCACOD bits for transaction type). This is uncorrected. This type of error should be a very rare event in normal operating conditions.  If this error is repeatable in any domain, is likely core voltage related or a specific part failure.  Please take steps to isolate the problem to a specific part or system. Gathering further information on the failure environment may also  be useful [Power management dependency for instance].']}},
{'bankType':'DTLB', 'fieldMask':0x0000000000070000,'AndMask':0x0000000000000005,'OrMask':0xffffffffffff0005,'genDesc':'Internal Parity Error','decode':{0: ['Reserved', ''], 1: ['Reserved', ''], 2: ['Internal Reg File Parity Error', ''], 3: ['Reserved', ''], 4: ['Internal Reg File Parity Error', ''], 5: ['Reserved', '']}},
{'bankType':'DTLB', 'fieldMask':0x0000000000030000,'AndMask':0x0000000000000010,'OrMask':0xffffffffffff001c,'genDesc':'DTLB Parity Error   ','decode':{0: ['DTLB Tag Parity Error', ''], 1: ['DTLB Data Parity Error', ''], 2: ['PDE Tag Parity Error', ''], 3: ['PDE Data Parity Error', '']}},
{'bankType':'DTLB', 'fieldMask':0x0000000000030000,'AndMask':0x0000000000000011,'OrMask':0xffffffffffff001d,'genDesc':'STLB Parity Error   ','decode':{0: ['STLB Tag Parity Error', ''], 1: ['STLB Data Parity Error', ''], 2: ['PDE Tag Parity Error', ''], 3: ['PDE Data Parity Error', '']}},
{'bankType':'DTLB', 'fieldMask':0x0000000000030000,'AndMask':0x0000000000000012,'OrMask':0xffffffffffff001f,'genDesc':'TLB Parity Error','decode':{0: ['TLB Tag Parity Error', ''], 1: ['TLB Data Parity Error', ''], 2: ['PDE Tag Parity Error', ''], 3: ['PDE Data Parity Error', '']}},
{'bankType':'DTLB', 'fieldMask':0x00000000000f0000,'AndMask':0x0000000000000406,'OrMask':0xffffffffffff0406,'genDesc':'Internal Control Flow Errors','decode':{0: ['Reserved', ''], 1: ['Reserved', ''], 2: ['Reserved', ''], 3: ['Internal Control Flow Error', ''], 4: ['Internal Control Flow Error', ''], 5: ['Reserved', '']}},
{'bankType':'MLC', 'fieldMask':0x0000000000800000,'AndMask':0x0000000000000400,'OrMask':0xffffffffffff0400,'genDesc':'Internal Error      ','decode':{0: ['No Error', ''], 1: ['Watchdog Timer (3-strike) Error', 'No core uops retired within the watchdog  timeout value. This value is nominally set to 21.47 seconds. This is not necessarily indicative of a CPU issue. The most common cause of this issue is a non-completion of a transaction by an external agent. The basic debug of this type of issue is to isolate this outstanding transaction. If the crashdump process is enabled for this platform, use the data for further fault isolation. The crashdump will extract outstanding transactions from the LLC ( Cbo TOR - Cbox Table of Requests). One of these is likely to be the source of the timeout condition.  Pay particular attention to the core id (not the same as APIC ID but can be derived) of this MCA bank and correlate it to the core id of the Cbo TOR array entries. There may be other side effect entries in the TOR, these could be disregarded.  This process will yield a starting point. The next step is to understand why this outstanding transaction has not been completed. One normally has to extract a system memory map from the failing UUT in order to isolate where in the system the address was targeted towards. This would be the basis of the next stage of the debug.']}},
{'bankType':'MLC', 'fieldMask':0x0000000000400000,'AndMask':0x0000000000000400,'OrMask':0xffffffffffff0407,'genDesc':'Internal Error      ','decode':{0: ['No Error', ''], 1: ['Internal Queue Parity Error', ''], 2: ['Reserved', '']}},
{'bankType':'MLC', 'fieldMask':0x0000000000300000,'AndMask':0x0000000000000101,'OrMask':0xffffffffffff11fd,'genDesc':'MLC Error           ','decode':{0: ['MLC Data No Error', ''], 1: ['MLC Data Single Error', 'MLC Data Read corrected error.  The MLC does implement Threshold based Error Status (TES) tracking. Please check the Mci_STATUS bits [54:53] for the code that represents the severity of the corrected error (green or yellow). Since this is a corrected error, it is possible that the operating system will have enabled CMCI signaling. This implies a few system operation type of issues that impact the debug flow. If the CMCI threshold is set to 1, and this log is extracted from an Operating system, then each error will represent a count of 1 (as the OS will read, log and clear the bits for each interrupt). The status of the TES bits are the best guideline for the issue. It should also be noted that errors of this sort are expected but are deemed to be rare. If the occurrence rate is large (TES reports yellow), steps should be take to isolate the problem to a specific part or some other system contribution (core power delivery or voltage).'], 2: ['MLC Data Double Error', 'MLC Data Read error.  This is an uncorrected error.  This type of error should be a very rare event in normal operating conditions.  If this error is repeatable in any domain, is likely core voltage related or a specific part failure.  Please take steps to isolate the problem to a specific part or system. Gathering further information on the failure environment may also  be useful [Power management dependency for instance]. If this error is coupled with previous failure data (a long succession of single bit errors with a TES state changing to Yellow), then it may be a sign of a part degrading.'], 3: ['Reserved', '']}},
{'bankType':'MLC', 'fieldMask':0x00000000000c0000,'AndMask':0x0000000000000101,'OrMask':0xffffffffffff11fd,'genDesc':'MLC Error           ','decode':{0: ['MLC MESI No Error', ''], 1: ['MLC MESI Corrected Error', 'MLC single bit corrected error in MESI state structure. The MLC does implement Threshold based Error Status (TES) tracking. Please check the Mci_STATUS bits [54:53] for the code that represents the severity of the corrected error (green or yellow). Since this is a corrected error, it is possible that the operating system will have enabled CMCI signaling. This implies a few system operation type of issues that impact the debug flow. If the CMCI threshold is set to 1, and this log is extracted from an Operating system, then each error will represent a count of 1 (as the OS will read, log and clear the bits for each interrupt). The status of the TES bits are the best guideline for the issue. It should also be noted that errors of this sort are expected but are deemed to be rare. If the occurrence rate is large (TES reports yellow), steps should be take to isolate the problem to a specific part or some other system contribution (core power delivery or voltage).'], 2: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod'], 3: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod']}},
{'bankType':'MLC', 'fieldMask':0x0000000000030000,'AndMask':0x0000000000000101,'OrMask':0xffffffffffff11fd,'genDesc':'MLC Error           ','decode':{0: ['MLC Tag No Error', ''], 1: ['MLC Tag Single Error', 'The MLC structure has detected a tag parity error (single bit error, uncorrected).   Failures of this type are very rare events under normal operating conditions.   If this error is repeatable in any domain, it is likely a core voltage related or a specific part failure.  The most common occurrence of an issue of this type is power delivery to the cpu core. This area is powered by the core voltage pins. Further data collection is necessary to understand the environment where the failure occurs.'], 2: ['MLC Tag Double Error', 'The MLC structure has detected a tag parity error (double bit error, uncorrected).   Failures of this type are very rare events under normal operating conditions.   If this error is repeatable in any domain, it is likely a core voltage related or a specific part failure.  The most common occurrence of an issue of this type is power delivery to the cpu core. This area is powered by the core voltage pins. Further data collection is necessary to understand the environment where the failure occurs.'], 3: ['Unexpected Encoding', 'Unexpected combination of mscod/mcacod']}},
{'bankType':'PCU', 'fieldMask':0x00000000ffff0000,'AndMask':0x0000000000000402,'OrMask':0xffffffffffff0402,'genDesc':'PCU FW Errors','decode':{18432: ['PCU Error:FW MCA_SVID_READ_REG_ICC_MAX_FAILED', ''], 1: ['PCU Error- Internal', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 2: ['PCU Error- Internal', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 3: ['PCU Error- Internal', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 4: ['PCU Error- Internal', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 5: ['PCU Error- Internal', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 6: ['PCU Error- Internal', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 7: ['PCU Error- Internal', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 8: ['PCU Error- Internal', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 9: ['PCU Error- Internal', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 33024: ['PCU Error:FW - MCA_RECOVERABLE_DIE_THERMAL_TOO_HOT', 'There is an issue with the processor thermal state. A catastrophic temperature was detected. Please check that the cooling solution for the processor is working correctly.'], 16: ['PCU H/W Error: SVID error', 'This error indicates a hardware error with the VRM. Bit 20 can be set independently of the other MSCOD bits.  Either a PSI command or a VID command encountered a VRM error.  Please check the VR itself for proper operation.'], 19: ['MCA_DMI_TRAINING_TIMEOUT', 'During reset, DMI2 training failed to complete within time-out. Possible DMI2 related failure.'], 21: ['MCA_DMI_CPU_RESET_ACK_TIMEOUT', 'During reset, DMI message for CPU Reset Ack did not arrive within timeout. Possible DMI2 related failure.'], 30: ['MCA_VR_ICC_MAX_LESS_THAN_FUSED_ICC_MAX', "During reset, the VR's Icc max limit was found to be lower than the expected Icc max value. Possible VR related failure."], 32: [' Generic Ubox/R2 error', 'This error code should not signal an IERR as it is a route-through of the Ubox and not PCU generated. This signaling is controlled via CSR (UBOXERRCTL). See the error status registers (UBOXERRSTS and UBOXERRMISC)  for detailed information on the source of this error.'], 37: ['MCA_SVID_COMMAND_TIMEOUT', 'SVID command time-out (busy bit was not cleared fast enough). Possible VR related failure.'], 17408: ['PCU Error:FW -MCA_CRITICAL_VR_FAILED', 'This error is related to a VR problem. Possible VR Related failures are: SVID bus error; missing VR; misconfigured VR.'], 41: ['MCA_VR_VOUT_MAC_LESS_THAN_FUSED_SVID', 'Boot SVID voltage are higher than what the VR can support Possible VR related failure.'], 43: ['MCA_PKGC_WATCHDOG_HANG_CBZ_DOWN', 'Pkg C-state hung at transient state: In Buffer Zone, going Down (towards C2/C3). Possible Intel QPI related failure.'], 44: ['MCA_PKGC_WATCHDOG_HANG_CBZ_UP', 'Pkg C-state hung at transient state: In Buffer Zone, going Up (towards C0). Possible Intel QPI or DMI2 related failure.'], 17664: ['PCU Error:FW -MCA_ICC_MAX_NOTSUPPORTED', 'Core VR does not support the  supplied current. Verify that the VR is providing the correct current.'], 17920: ['PCU Error:FW -MCA_VID_RAMP_DOWN_FAILED', ''], 57: ['MCA_PKGC_WATCHDOG_HANG_C3_UP_SF', 'Pkg C-state hanged at transient state: In C3, towards C2, slow/fast volrage ramp.'], 18176: ['PCU Error:FW -MCA_EXCL_MODE_NO_PMREQ_CMP', ''], 68: ['MCA_CRITICAL_VR_FAILED', 'In Config SVID IFC it was detected that either Core VR or SA VR failed to respond. Possible VR or SVID related failure.'], 69: ['MCA_ICC_MAX_NOTSUPPORTED', 'Core VR does not support required current for the part. Possible VR related failure.'], 70: ['MCA_VID_RAMP_DOWN_FAILED', 'VID Ramp-down failed in phase 4. Possible VR or SVID related failure.'], 71: ['MCA_EXCL_MODE_NO_PMREQ_CMP', 'On Exclusive Mode entry, wait for QPI completion of PMReq messages timed out. Possible Intel QPI or DMI2 related failure.'], 72: ['MCA_SVID_READ_REG_ICC_MAX_FAILED', 'SVID command to read ICC_MAX register failed. Possible VR related failure.'], 73: ['MCA_SVID_WRITE_REG_VOUT_MAX_FAILED', 'SVID command to write VOUT MAX register failed. Possible VR related failure.'], 75: ['MCA_PP1_BOOT_VID_TIMEOUT', 'Timeout setting boot VID for PP1 (DRAM 0). Possible VR related failure.'], 76: ['MCA_AUX_BOOT_VID_TIMEOUT', 'Timeout setting boot VID for AUX PP (DRAM 1). Possible VR related failure.'], 77: ['MCA_PP4_BOOT_VID_TIMEOUT', 'Timeout setting boot VID for PP3 (DRAM 2). Possible VR related failure.'], 18688: ['PCU Error:FW -MCA_SVID_WRITE_REG_VOUT_MAX_FAILED', ''], 79: ['MCA_SVID_COMMAND_ERROR', 'General SVID command error. Possible VR or SVID related failure.'], 82: ['MCA_FIVR_CATAS_OVERVOL_FAULT', 'Catastrophic over voltage IVR fault'], 83: ['MCA_FIVR_CATAS_OVERCUR_FAULT', 'Catastrophic overcurrent FIVR fault'], 87: ['MCA_SVID_PKGC_REQUEST_FAILED', 'SVID Pkgc request failed. Possible VR related failure.'], 88: ['MCA_SVID_IMON_REQUEST_FAILED', 'SVID IMON request failed. Possible VR related failure.'], 89: ['MCA_SVID_ALERT_REQUEST_FAILED', 'SVID ALERT request failed. Possible VR related failure.'], 19200: ['PCU Error:FW -MCA_PP1_BOOT_VID_TIMEOUT', ''], 96: ['MCA_INVALID_PKGS_REQ_PCH', 'PkgS Master detected improper request from PCH. Possible PCH or DMI2 related failure.'], 97: ['MCA_INVALID_PKGS_REQ_QPI', 'PkgS Slave detected improper request from Master. Possible Intel QPI error.'], 98: ['MCA_INVALID_PKGS_RSP_QPI', 'PkgS Master detected improper response from Slave. Possible Intel QPI error.'], 99: ['MCA_INVALID_PKGC_RSP_PCH', 'PkgC Master detected improper response from PCH for EA request. Possible PCH or DMI2 related failure.'], 100: ['MCA_INVALID_PKG_STATE_CONFIG', 'Invalid pkg-state configuration detected (Master and no slave mask). Possible BIOS setting or Power Management configuration.'], 19456: ['PCU Error:FW -MCA_AUX_BOOT_VID_TIMEOUT', ''], 103: ['MCA_HA_IMC_RW_BLOCK_ACK_TIMEOUT', 'Timeout waiting for BlockAck from HA\\IMC in S3/RW flow'], 104: ['MCA_IMC_RW_SMBUS_TIMEOUT', 'Timeout waiting for IMC SMBUS not-busy in S3 or Reset Warn. Possible SPD or SMBUS related failure.'], 105: ['MCA_HA_FAILSTS_CHANGE_DETECTED', 'Detected change in HACHFAILSTS - mirroring failover error detected. Possible mirroring failover related failure.'], 106: ['MCA_MSGCH_PMREQ_CMP_TIMEOUT', 'Timeout waiting for PMReq.CMP to be set - MsgCh driver. Possible Intel QPI related failure.'], 19712: ['PCU Error:MCA_PP4_BOOT_VID_TIMEOUT', ''], 112: ['MCA_WATCHDOG_TIMEOUT_PKGC_SLAVE', 'PkgC slave timedout waiting for PmRsp from Master. Possible Intel QPI or Ubox configuration related failure.'], 113: ['MCA_WATCHDOG_TIMEOUT_PKGC_MASTER', 'PkgC master timed-out waiting for PmRsp from PCH. Possible PCH or DMI2 related failure.'], 114: ['MCA_WATCHDOG_TIMEOUT_PKGS_MASTER', 'PkgS master timed-out waiting for PmRsp from slave. Possible Intel QPI or Ubox configuration related failure.'], 19968: ['PCU Error:FW -MCA_PP5_BOOT_VID_TIMEOUT', ''], 124: ['MCA_BIOS_RST_CPL_INVALID_SEQ', 'BIOS voilated BIOS Reset CPL sequencing requirements. Possible BIOS related issue.'], 125: ['MCA_MORE_THAN_ONE_LT_AGENT', 'During Boot Mode Processing, >1 Intel TXT Agent detected. Possible Intel QPI BIOS/BMC setting issue.'], 20224: ['PCU Error:FW -MCA_SVID_COMMAND_ERROR', ''], 129: ['MCA_RECOVERABLE_DIE_THERMAL_TOO_HOT', 'During slow loop, it was detected that internal die is too hot. Possible thermal related failure.'], 20480: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 20736: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 20992: ['PCU Error:FW - MCA_FIVR_CATAS_OVERVOL_FAULT', 'This error reflects an catastrophic overvoltage condition detected by the internal voltage regulator.'], 21248: ['PCU Error:FW - MCA_FIVR_CATAS_OVERCUR_FAULT', 'This error reflects an catastrophic overcurrent condition detected by the internal voltage regulator.'], 21504: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 21760: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 22016: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 33536: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 22272: ['PCU Error:FW - MCA_SVID_PKGC_REQUEST_FAILED', 'Possible VR related issues'], 22528: ['PCU Error:FW - MCA_SVID_IMON_REQUEST_FAILED', 'Possible VR related issues'], 22784: ['PCU Error:FW - MCA_SVID_ALERT_REQUEST_FAILED', 'Possible VR related issues'], 23040: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 17152: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 24576: ['PCU Error:FW - MCA_INVALID_PKGS_REQ_PCH', 'An improper request was received from the PCH. Please verify the health of the processor or the PCH. This may also be related to a DMI related issue.'], 34048: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 24832: ['PCU Error:FW - MCA_INVALID_PKGS_REQ_QPI', 'The PCU has received an invalid package S state request. This may be a qpi related issue or an internal corruption event of the packet as it is transmitted from the QPI block into the PCU.'], 25088: ['PCU Error:FW - MCA_INVALID_PKGS_RSP_QPI', 'The PCU has received an invalid package S response from the QPI. This may be a qpi related issue or an internal corruption event of the packet as it is transmitted from the QPI block into the PCU.'], 25344: ['PCU Error:FW - MCA_INVALID_PKGC_RSP_PCH', 'The PCU has received an invalid package C response from the PCH. This is either a PCH related issue or a DMI related problem.'], 25600: ['PCU Error:FW -MCA_INVALID_PKG_STATE_CONFIG', 'The package state configuration was found to be invalid. Please check the values used to initialize GLOBAL_PKG_C_S_CONTROL_REGISTER and/or GLOBAL_NID_MAP_REGISTER'], 25856: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 26112: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 26368: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 26624: ['PCU Error:FW - MCA_IMC_RW_SMBUS_TIMEOUT', 'This error is caused by a timeout on the SMBus as the iMC is accessing the SPD. This can be due to a hung bus or an issue with the SPD device itself.'], 26880: ['PCU Error:FW - MCA_HA_FAILSTS_CHANGE_DETECTED', 'This error is caused by a mirroring related failure. A problem has occurred during a mirroring operation.'], 27136: ['PCU Error:FW - MCA_MSGCH_PMREQ_CMP_TIMEOUT', "This error is caused by a timeout for a PMREQ completion response. This maybe due to a QPI bus issue (prevention of completion from retiring). It is also possible for a UBOX configuration to impact this issue as it is the 'collector' of pmreq completion responses."], 28672: ['PCU Error:FW - MCA_WATCHDOG_TIMEOUT_PKGC_SLAVE', "The PCU has detected a package C slave time out condition while waiting for a PmRsp from the master. There may be an issue with the PM 'master' in the cycle. To debug this sort of problem, the pm master has to be identified and the a trace of the power management handshake process has to be monitored.  If there are QPI related issues that accompany this error, the two may be related as the QPI bus is used to transmit the PM packet handshakes."], 28928: ['PCU Error:FW - MCA_WATCHDOG_TIMEOUT_PKGC_MASTER', 'The PCU has detected a package C master time out condition while waiting for a PmRsp from the PCH. There  may be an issue with the PCH side of the transaction. One will have to check for the PCH status and why it was unable to respond with a PmRsp.'], 29184: ['PCU Error:FW - MCA_WATCHDOG_TIMEOUT_PKGS_MASTER', 'PackageS timeout during a warm reset or during entry to S3 has been detected. There may be multiple possible reasons for this behavior.'], 29440: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 29696: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 29952: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 78: ['MCA_PP5_BOOT_VID_TIMEOUT', 'Timeout setting boot VID for PP4 (DRAM 3). Possible VR related failure.'], 31744: ['PCU Error:FW - MCA_BIOS_RST_CPL_INVALID_SEQ', 'This can be caused by in correct BIOS programming.'], 32000: ['PCU Error:FW - MCA_MORE_THAN_ONE_LT_AGENT', 'The PCU has detected more than one TXT agent. This is not allowed. This can be a side effect of a QPI issuer or a programming error (BIOS). The two possibilities should be checked.'], 32256: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.'], 32512: ['PCU Error:FW - Internal Error', 'This error code is a PCU reported internal error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment). If this error is not accompanied by any other bank errors, it is a possible part specific issue.']}},
{'bankType':'QPI', 'fieldMask':0x00000000ffff0000,'AndMask':0x00000000ffff0000,'OrMask':0xffffffff0000ffff,'genDesc':'QPI Errors','decode':{0: ['QPI Error - Phy Control Error', 'This error code is unexpected for HSX as it is not designed to signal a phy control error. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment).\n'], 32: ['QPI Error - Correctable: Phy Initialization Abort', "QPI Link was not able to go through a normal training sequence and had to be aborted and reattempted. The errors are logged in 'QPIREUT_PH_PPS' for the particular port [B: 1 D:[9:8] F:3 O:144h. This register is the Phy later previous initialization status and it captures state information related to the aborted sequence. One will have to have some knowledge of QPI link training to make use of this information. There are good writeups of link training debug in the platform debug handbook."], 2: ['QPI Error - Physical Layer Detected Drift Buffer Alarm', 'QPI Error - Drift buffer Overrun. Additional debug information is stored in QPIREUT_PH_PLS  register.  Bits 20:16 log the first lane to report a drift buffer alarm. Bits 6-4 also have additional drift buffer statusing.  An error of this type may point to an electrical issue the other register info may help for isolation.'], 3: ['QPI Error - Physical Layer Detected Latency Buffer Rollover', 'QPI Error - Latency buffer Over/Under run. Additional debug information is stored in the QPIREUT_PH_PLS register (bit 2).  This error code should only occur in cases or instances where latency fixing is being performed on the platform.  The implication is that the latency values should be adjusted (lengthen) to ensure that the buffers are not being overrun.'], 48: ['QPI Error - Correctable: Rx CRC Error with LLR Success no Phy reset', ' A QPI Rx CRC Error which required a link level retry  has been detected.  Escalation to a physical layer reinitialization was not necessary.  This is considered a temporary physical layer event.'], 49: ['QPI Error - Correctable: Tx CRC Error', 'QPI Tx received a link level retry. This error is normally recommend to be disabled as it is a side effect of Rx CRC error on the other end of the QPI link. This is considered a temporary soft error type of event.'], 35: ['QPI Error - Correctable: Rx CRC Error with LLR success after phy reset', 'QPI Physical Layer detected a QPI inband reset which resulted in a Width Change . This is not supported on HSX-EN/EP and should never be seen in those SKUs.  For HSX-EX, this code may be reported for a clock fail over event.  To identify the failed lane, check the QPIREUT_PH_TDS/RDS registers. '], 33: ['QPI Error - Correctable: Phy Inband Reset and Width Degradation ', 'QPI Physical Layer detected a QPI inband reset which resulted in a Width Change (lane failover). This is not supported on HSX-EN/EP and should never be seen in those SKUs.  For HSX-EX, this code may be reported for a link fail over event.  To identify the failed lane, check the QPIREUT_PH_TDS/RDS registers.\n\nNote for IVT/HSX - this error code will pretty much always be overwritten by 0x31 please consult the TDS/RDS registers to isolate the details of the width change.  '], 34: ['QPI Error - Correctable: Phy Inband Reset and no width change', 'QPI Physical Layer detected a QPI inband reset. Width did not change. One failure in isolation is normally not a concern, repeated failures and logging of this error code would imply link health issues.'], 50: ['QPI Error - TX Detected CRC', 'This error code is legal and valid but normally not expected as it is recommended that masking is used to disable this error logging and escalation.  The first thing to check for is proper mode (did we want to disable this escalation or not). If the intent was to disable the logging/signaling then it becomes an exercise in calculating the recipe to mask the error. This is normally defined in the BIOS writers guide.'], 16: ['QPI Error - Link Layer Detected Control Error from R3QPI ', 'QPI link layer detected control error or R3QPI error. This type of error should be a very rare event under normal operating conditions.   It is possible for a credit configuration issue can generate this error code. A credit issue can translate to overrun or underflow of a R3QPI internal buffering structure.  Another possibility is that there may be e a parity error in the same structures in EP sku platforms when Viral is not enabled).'], 17: ['QPI Error - Failed Link Layer Retry', 'QPI Rx detected a CRC error and was not able to recover through Link Layer Replay and Re-Init (LLR Abort state). Essentially the link could not recover from a detected CRC error. This could be an interface issue (bus or bus margin) or some environmental factor (pin/socket issues) or an issue with a specific part.'], 18: ['QPI Error - Unsupported/Undefined Packet', 'QPI Link Layer detected an unsupported/undefined packet (e.g. RSVD_CHK, message class, op code, VN, viral). An error of this type that is not accompanied by CRC errors is a link layer issue (not physical layer problem). This implies potential programming or interface to another agent (node controller) that may incorrectly fill in fields of the packet.'], 19: ['QPI Error - Link Layer Control Error', 'Generic QPI Link Layer Error which cannot be resolved. Most occurrences are bi-product of poor general link health.'], 20: ['QPI Error - Link Layer L0p Retrain Error', 'This error condition is not expected on HSX platforms. HSX behavior is to trigger an inband reset flow on this condition (this differs from previous generations).  If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment).'], 21: ['QPI Error - Link Layer RBT Error', 'Route Back Table (RBT) error. Uninitialized value used. The implication is that the RBT has not been programmed correctly.  Check the RBT programming sequence to verify that this process has been completed by the platform FW and that this has been done correctly.'], 22: ['QPI Error - Reserved', 'This error should not be visible, it is reserved for IVB-EP/EX usage. It is not expected to be seen on this platform. If this code appears in an error, other mca bank values should also be checked to ensure the processor is running in a normal or linear mode ( proper voltage, frequency and power operational environment).'], 31: ['QPI Error - Unsupported Configuration Request from Message Channel', 'QPI Configuration access crossing a 32 bit boundary.  The QPI subsystem on the socket has received a configuration request that crosses a 32 bit boundary. This is not allowed. ']}},
{'bankType':'IIO', 'fieldMask':0x00000000ffff0000,'AndMask':0x000000000000ffff,'OrMask':0xffffffffffff0000,'genDesc':'IIO Generic Error','decode':{0: ['Generic Error', 'See PCIe error status values for specific decoders.  This is an EX SKU feature only.  The MCI_MISC register logs  bus, device, function logs.  This should allow for isolation and correlation of machine check banks to PCIe error status registers. ']}},
{'bankType':'HA', 'fieldMask':0x00000000ffff0000,'AndMask':0x00000000ffff0000,'OrMask':0xffffffff0000ffff,'genDesc':'Home Agent Error','decode':{32: ['Internal parity error in Home Agent', 'Internal parity error.  This type of error should be a rare event in normal operating conditions.  If this error is repeatable in any domain, is likely core voltage related or a specific part failure.  Please take steps to isolate the problem to a specific part or system. Gathering further information on the failure environment may also  be useful [Power management dependency for instance].'], 1: ['HA Error - Read Data Error ', 'Memory controller read error logged. Note the corrected or uncorrected status in bit 61 of MC_STATUS.  The channel number is logged as part of the MCACOD value. If the error is corrected the corrected error count should note the number of events that have occurred since power on. \n\nIf CMCI is enabled, this count may appear to be the value of the threshold that was set for CMCI signaling. This is because the interrupt will occur on the threshold value and the CMCI handler would normally log the value and clear it.  Note what system configuration has been enabled (CMCI enabled and what the threshold was set to) in order to get an accurate picture of the problem.'], 2: ['HA Error - Data Buffer Parity', 'HA data buffer parity error.  This error represents a bit flip in the data buffer or a parity error on the read path from iMC to HA.  This type of error should be a rare event in normal operating conditions.  If this error is repeatable in any domain, is likely core voltage related or a specific part failure.  Please take steps to isolate the problem to a specific part or system. Gathering further information on the failure environment may also  be useful [Power management dependency for instance].'], 4: ['HA Error - Partial Write', 'A partial memory write error has occurred. This is due to an underfill read error.'], 8: ['HA Error - Rx timing violation', 'Data from the MC to the HA has violated a timing restriction.  This type of error should be a rare event in normal operating conditions.  If this error is repeatable in any domain, is likely core voltage related or a specific part failure.  Please take steps to isolate the problem to a specific part or system. Gathering further information on the failure environment may also  be useful [Power management dependency for instance].'], 64: ['Internal parity error in Home Agent', 'Internal parity error.  This type of error should be a rare event in normal operating conditions.  If this error is repeatable in any domain, is likely core voltage related or a specific part failure.  Please take steps to isolate the problem to a specific part or system. Gathering further information on the failure environment may also  be useful [Power management dependency for instance].'], 128: ['Internal parity error in Home Agent', 'Internal parity error.  This type of error should be a rare event in normal operating conditions.  If this error is repeatable in any domain, is likely core voltage related or a specific part failure.  Please take steps to isolate the problem to a specific part or system. Gathering further information on the failure environment may also  be useful [Power management dependency for instance].'], 256: ['Internal parity error in Home Agent', 'Internal parity error.  This type of error should be a rare event in normal operating conditions.  If this error is repeatable in any domain, is likely core voltage related or a specific part failure.  Please take steps to isolate the problem to a specific part or system. Gathering further information on the failure environment may also  be useful [Power management dependency for instance].'], 16: ['HA Error - RTID Out of Range', 'An RTID value was generated and checked to be out of range by the HA. The RTID source is either the Cbo or QPI. The error is either an internally generated error (Cbo in the same socket as the HA) or external (via QPI).'], 512: ['HA Error - BT_timeout_error', "HA Backup tracker timeout error. A HA transaction has timed out. There is little tracking information logged in the MCA status banks for this. If the source of this transaction was local to this socket a corresponding Cbo Timeout should have occurred. If the transaction was from a remote socket, that socket's Cbo Timeout would have expired (check the MCA banks for that socket). If the source transaction is from a node controller device, then it's timeout mechanism should be consulted for the source transaction. This error code and bank error is used more for helping with the fault isolation. In some cases the opcode of the transaction is logged in the MCi_MISC field. If this is valid the decode would appear there."]}},
{'bankType':'IMC', 'fieldMask':0x00000000ffff0000,'AndMask':0x00000000ffff0000,'OrMask':0xffffffff0000ffff,'genDesc':'Integrated Memory Controller Error','decode':{64: ['iMC Error - Sparing [Uncorrected]', "A memory sparing event has occurred and the error is uncorrected.  Address is logged in MCx_Address. In the case of poison enabled mode (advanced SKU's only), this error may be escalated to a CMCI and 'deferred'. This would be spelled out in the S and AR bits of the MCi_STATUS banks. As such, CMCI 'rules' apply here.  Similar to corrected error flows, it is possible for the operating system to enable CMCI escalation and logging. The value of the Mci_STATUS bank has to bear the context of CMCI behavior related to the OS handler (read, log and clear). If the OS has enabled CMCI then the full context would have to be taken with other log data. This would give you the full detail of corrected error rate information. This applies as well to the MCi_ADDR register. It may be logged and cleared by the OS."], 32: ['iMC Error - Sparing [Corrected]', 'A memory sparing event has occurred and the error is corrected. As with all corrected error flows, it is possible for the operating system to enable CMCI escalation and logging. The value of the Mci_STATUS bank has to bear the context of CMCI behavior related to the OS handler (read, log and clear). If the OS has enabled CMCI then the full context would have to be taken with other log data. This would give you the full detail of corrected error rate information. This applies as well to the MCi_ADDR register. It may be logged and cleared by the OS.'], 2: ['iMC Error - Data Write Parity Error', ''], 4: ['iMC Error - Bye Enable Parity Error', ''], 1: ['iMC Error - DDR3 Address Parity Error', 'iMC an error occurred in the  address/command parity error has been detected. This is detected by the DIMM and signaled back to the iMC. Note the channel number from the Mci_STATUS bank information and isolate to the DIMM for further fault isolation.'], 8: ['iMC Error - Patrol Scrub Error [Corrected]', 'The patrol scrubber has detected an error and corrected it.  Address logged in MCx_Address bank.  The patrol scrub logged address is only accurate to 4K boundary (lower 12 bits should be ignored). As with all corrected error flows, it is possible for the operating system to enable CMCI escalation and logging. The value of the Mci_STATUS bank has to bear the context of CMCI behavior related to the OS handler (read, log and clear). If the OS has enabled CMCI then the full context would have to be taken with other log data. This would give you the full detail of corrected error rate information. This applies as well to the MCi_ADDR register. It may be logged and cleared by the OS.'], 128: ['iMC Error - Read [Corrected]', ''], 257: ['iMC Error - Intel SMI2 Error', 'Intel SMI2 Error (For EX processor, the DDR Address Parity Error will be reported as Intel SMI2 Error)'], 256: ['iMC Error - WDB Parity', ''], 16: ['iMC Error - Patrol Scrub Error [Uncorrected]', "The patrol scrubber has detected an uncorrected error. Address is logged in MCx_Address. The patrol scrub logged address is only accurate to 4K boundary (lower 12 bits should be ignored). In the case of poison enabled mode (advanced SKU's only), this error may be escalated to a CMCI and 'deferred'. This would be spelled out in the S and AR bits of the MCi_STATUS banks. As such, CMCI 'rules' apply here.  Similar to corrected error flows, it is possible for the operating system to enable CMCI escalation and logging. The value of the Mci_STATUS bank has to bear the context of CMCI behavior related to the OS handler (read, log and clear). If the OS has enabled CMCI then the full context would have to be taken with other log data. This would give you the full detail of corrected error rate information. This applies as well to the MCi_ADDR register. It may be logged and cleared by the OS."], 512: ['iMC - Error - DDR4 Command Address Parity Error', '']}},
{'bankType':'Cbo/LLC', 'fieldMask':0x00000000ffff0000,'AndMask':0x00000000ffff0000,'OrMask':0xffffffff0000ffff,'genDesc':'LLC Errors','decode':{1: ['Cbo Error - UC Data Err - Crd (UCNA)', 'LLC has detected an uncorrected error (multibit) the data array. The transaction type that caused the error are logged in the MCACOD section of the MCi_STATUS bank.  Errors of this sort are expected but are deemed to be rare.  If the occurrence of these errors are frequent, steps should be take to isolate the problem to a specific part or some other system contribution (uncore power delivery or voltage).'], 2: ['Cbo Error - UC Tag Err', 'The LLC has detected an uncorrected error (multibit)  in the tag array. The transaction type that caused the error are logged in the MCACOD section of the MCi_STATUS bank.  Errors of this sort are expected but are deemed to be rare.  If the occurrence of these errors are frequent, steps should be take to isolate the problem to a specific part or some other system contribution (uncore power delivery or voltage).'], 3: ['Cbo Error - SAD ERR WBMto_type (VGA, PAM )', 'This error occurs when the SAD detects an implicit or explicit writeback to  the following regions areas that are deemed to be illegal : 1) Explicit Writeback access to true VGA range or 2) Implicit/Explicit Writeback to PAM region that does not map to non-DRAM.  These errors are likely software generated and the offending code will have to be isolated (memory mapping software).'], 4: ['Cbo Error - Internal', ''], 5: ['Cbo Error - SAD ERR Corrupting', 'This is caused by 1) Set Monitor transaction to MMIO space 2) Cacheable read to VGA region 3) PCIE to SMM: violation that IIO is trying to access CSEG region (VGA region is mapped for CSEG/SMM) 4) SMM RspM: Implicit WB data when VGA/CSEG range is mapped to true VGA 5) CrabRspM: Implicit WB to CRAB_Abort range of MMCFG range. Check for these error conditions in software.'], 6: ['Cbo Error - SAD ERR Non Corrupting', 'This error is signaled when a CLFlush occurs to VGA/CSEG region of memory. This is not allowed and suggests an incorrect cacheability region to VGA/CSEG.'], 7: ['Cbo Error - Corrected Data Error', 'The LLC has detected and corrected (single bit error in data) an error. The LLC does implement Threshold based Error Status (TES) tracking. Please check the Mci_STATUS bits [54:53] for the code that represents the severity of the corrected error (green or yellow). Since this is a corrected error, it is possible that the operating system will have enabled CMCI signaling. This implies a few system operation type of issues that impact the debug flow. If the CMCI threshold is set to 1, and this log is extracted from an Operating system, then each error will represent a count of 1 (as the OS will read, log and clear the bits for each interrupt). The status of the TES bits are the best guideline for the issue. It should also be noted that errors of this sort are expected but are deemed to be rare. If the occurrence rate is large (TES reports yellow), steps should be take to isolate the problem to a specific part or some other system contribution (core power delivery or voltage).'], 8: ['Cbo Error - Internal', ''], 10: ['Cbo Error - Uncorrected Parity Error', 'The LLC has detected a parity error on the ring interface. This is an uncorrected error.  This type of error should be a very rare event in normal operating conditions.  If this error is repeatable in any domain, is likely core voltage related or a specific part failure.  Please take steps to isolate the problem to a specific part or system. Gathering further information on the failure environment may also  be useful [Power management dependency for instance].'], 11: ['Cbo Error - Internal', ''], 12: ['Cbo Error - TOR_TIMEOUT', "The Cbo Table of Request (TOR) timer has expired on a transaction. This status value should be accompanied by valid MISC and ADDR bank register values. The transaction address and type are encoded in those registers. The MISC register will log the: Core ID, Thread ID, Cacheability, Original Request and Opcode.  The Original Request field should be used to note the request type. The opcode field will likely state a TOR Timeout and may not be as useful.  The ADDR register contains the target physical address. It should be noted that the address field does not have byte granularity (lower 6 bits are not decoded). this will make exact access difficult, but we get into the right area. The process for this error is to isolate the Original request, core/thread id and address and to map them back via a system memory mapping function. This is normally taken from the system when it boots up again. \n\nThis decode is normally accompanied by an MLC (three strike timeout) machine check. The address logged in that bank will log the EIP value at the time of the three strike. The core id logged in the Cbo timeout MISC register should align with the core MLC machine check. In the case of multiple 'hits' this may be used to correlate multiple stuck transactions to the cores that allocated these transactions."], 13: ['Cbo Error - Internal Error', ''], 14: ['Cbo Error - Internal Error', ''], 15: ['Cbo Error - Internal Error', ''], 17: [' LLC_TAG_CORR_ERR', ''], 18: ['LLC_STATE_CORR_ERR', ''], 19: ['Cbo Error - Internal', ''], 20: ['LLC_CV_CORR_ERR', ''], 21: ['LLC_CV_UNCORR_ERR', ''], 22: ['Internal Protocol Error', ''], 23: ['Cbo Error - MSCOD_MULT_LLC_WAY_TAG_MATCH', 'This code represents a multiple tag match in the LLC lookup. An error of this type is normally associated with a soft error. This type of error should be very rare. If the error is not rare, then possible paths for isolation are to look at a part specific issuer or platform power delivery to the part. In both cases they may be accompanied by other errors reported. If viral is enabled (EX), this error will trigger an event.'], 24: ['Cbo Error - MSCOD_REQ_RTID_TABLE_MISS_DATA', ''], 25: ['Cbo Error - MSCOD_REQ_RTID_TABLE_MISS_NON_DATA', ''], 26: ['Cbo Error - MSCOD_REQ_RTID_TABLE_MULTIHIT_DATA', ''], 27: ['Cbo Error - MSCOD_REQ_RTID_TABLE_MULTIHIT_NON_DATA', ''], 28: ['Cbo Error - Internal', ''], 29: ['Cbo Error - Internal', ''], 30: ['Cbo Error - Internal', ''], 31: ['Cbo Error - Internal', '']}},
	 ]

_mcRegs = {0:{"type":"core",    "name":"IFU",  "ctl":"ifu_cr_mc0_ctl",  "ctl2":None,               "status":"ifu_cr_mc0_status",  "addr":"ifu_cr_mc0_addr", "misc":"ifu_cr_mc0_misc",  "misc2":"ifu_cr_mc0_misc2"},
           1:{"type":"core",    "name":"DCU",  "ctl":"dcu_cr_mc1_ctl",  "ctl2":None,               "status":"dcu_cr_mc1_status",  "addr":"dcu_cr_mc1_addr", "misc":"dcu_cr_mc1_misc",  "misc2":"dcu_cr_mc1_misc2"},
           2:{"type":"core",    "name":"DTLB", "ctl":"dcu_cr_mc1_ctl",  "ctl2":None,               "status":"dtlb_cr_mc2_status", "addr":"dcu_cr_mc2_addr", "misc":"dcu_cr_mc2_misc",  "misc2":"dtlb_cr_mc2_misc2"},
           3:{"type":"core",    "name":"MLC",  "ctl":"ml2_cr_mc3_ctl",  "ctl2":None,               "status":"ml2_cr_mc3_status",  "addr":"ml2_cr_mc3_addr", "misc":"ml2_cr_mc3_misc",  "misc2":"ml2_cr_mc3_misc2"},
           4:{"type":"uncore",  "name":"PCU",  "ctl":"pcu_cr_mc_ctl",   "ctl2":"pcu_cr_mc_ctl2",   "status":"pcu_cr_mc_status",   "addr":"pcu_cr_mc_addr",  "misc":"pcu_cr_mc_misc",   "misc2":None},
           5:{"type":"uncore",  "name":"QPI0", "ctl":"qpi0_qpi_mc_ctl", "ctl2":"qpi0_qpi_mc_ctl2", "status":"qpi0_qpi_mc_st",     "addr":"qpi0_qpi_mc_ad",  "misc":"qpi0_qpi_mc_misc", "misc2":None},
           6:{"type":"uncore",  "name":"IIO",  "ctl":"iio_cr_mc_ctl",   "ctl2":"iio_cr_mc_ctl2",   "status":"iio_cr_mc_status",   "addr":"iio_cr_mc_addr",  "misc":"iio_cr_mc_misc",   "misc2":None},
           7:{"type":"uncore",  "name":"HA0",  "ctl":"ha0_mc5_ctl",     "ctl2":"ha0_mc5_ctl2",     "status":"ha0_mc5_status",     "addr":"ha0_mc5_addr",    "misc":"ha0_mc5_misc",     "misc2":None},
           8:{"type":"uncore",  "name":"HA1",  "ctl":"ha1_mc5_ctl",     "ctl2":"ha1_mc5_ctl2",     "status":"ha1_mc5_status",     "addr":"ha1_mc5_addr",    "misc":"ha1_mc5_misc",     "misc2":None},
           9:{"type":"uncore",  "name":"iMC0 C0", "ctl":"imc0_epmcdp01_imc0_mc_ctl", "ctl2":"imc0_epmcdp01_imc0_mc_ctl2", "status":"imc0_epmcdp01_imc0_mc_status", "addr":"imc0_epmcmain_imc0_mc8_addr", "misc":"imc0_epmcdp01_imc0_mc_misc", "misc2":None},
           10:{"type":"uncore", "name":"iMC0 C1", "ctl":"imc0_epmcdp01_imc1_mc_ctl", "ctl2":"imc0_epmcdp01_imc1_mc_ctl2", "status":"imc0_epmcdp01_imc1_mc_status", "addr":"imc0_epmcmain_imc1_mc9_addr", "misc":"imc0_epmcdp01_imc1_mc_misc", "misc2":None},
           11:{"type":"uncore", "name":"iMC0 C2", "ctl":"imc0_epmcdp23_imc0_mc_ctl", "ctl2":"imc0_epmcdp23_imc0_mc_ctl2", "status":"imc0_epmcdp23_imc0_mc_status", "addr":"imc0_epmcmain_imc2_mca_addr", "misc":"imc0_epmcdp23_imc0_mc_misc", "misc2":None},
           12:{"type":"uncore", "name":"iMC0 C3", "ctl":"imc0_epmcdp23_imc1_mc_ctl", "ctl2":"imc0_epmcdp23_imc1_mc_ctl2", "status":"imc0_epmcdp23_imc1_mc_status", "addr":"imc0_epmcmain_imc3_mcb_addr", "misc":"imc0_epmcdp23_imc1_mc_misc", "misc2":None},
           13:{"type":"uncore", "name":"iMC1 C0", "ctl":"imc1_epmcdp01_imc0_mc_ctl", "ctl2":"imc1_epmcdp01_imc0_mc_ctl2", "status":"imc1_epmcdp01_imc0_mc_status", "addr":"imc1_epmcmain_imc0_mc8_addr", "misc":"imc1_epmcdp01_imc0_mc_misc", "misc2":None},
           14:{"type":"uncore", "name":"iMC1 C1", "ctl":"imc1_epmcdp01_imc1_mc_ctl", "ctl2":"imc1_epmcdp01_imc1_mc_ctl2", "status":"imc1_epmcdp01_imc1_mc_status", "addr":"imc1_epmcmain_imc1_mc9_addr", "misc":"imc1_epmcdp01_imc1_mc_misc", "misc2":None},
           15:{"type":"uncore", "name":"iMC1 C2", "ctl":"imc1_epmcdp23_imc0_mc_ctl", "ctl2":"imc1_epmcdp23_imc0_mc_ctl2", "status":"imc1_epmcdp23_imc0_mc_status", "addr":"imc1_epmcmain_imc2_mca_addr", "misc":"imc1_epmcdp23_imc0_mc_misc", "misc2":None},
           16:{"type":"uncore", "name":"iMC1 C3", "ctl":"imc1_epmcdp23_imc1_mc_ctl", "ctl2":"imc1_epmcdp23_imc1_mc_ctl2", "status":"imc1_epmcdp23_imc1_mc_status", "addr":"imc1_epmcmain_imc3_mcb_addr", "misc":"imc1_epmcdp23_imc1_mc_misc", "misc2":None},
           17:{"type":"uncore", "name":"CBO0", "ctl":"virtual_msr_cr_cbo_merge0_mc_ctl", "ctl2":"virtual_msr_cr_cbo_merge0_mc_ctl2", "status":"virtual_msr_cr_cbo_merge0_mc_status", "addr":"virtual_msr_cr_cbo_merge0_mc_addr", "misc":"virtual_msr_cr_cbo_merge0_mc_misc", "misc2":None},
           18:{"type":"uncore", "name":"CBO1", "ctl":"virtual_msr_cr_cbo_merge1_mc_ctl", "ctl2":"virtual_msr_cr_cbo_merge1_mc_ctl2", "status":"virtual_msr_cr_cbo_merge1_mc_status", "addr":"virtual_msr_cr_cbo_merge1_mc_addr", "misc":"virtual_msr_cr_cbo_merge1_mc_misc", "misc2":None},
           19:{"type":"uncore", "name":"CBO2", "ctl":"virtual_msr_cr_cbo_merge2_mc_ctl", "ctl2":"virtual_msr_cr_cbo_merge2_mc_ctl2", "status":"virtual_msr_cr_cbo_merge2_mc_status", "addr":"virtual_msr_cr_cbo_merge2_mc_addr", "misc":"virtual_msr_cr_cbo_merge2_mc_misc", "misc2":None},
           20:{"type":"uncore", "name":"QPI1", "ctl":"qpi1_qpi_mc_ctl", "ctl2":"qpi1_qpi_mc_ctl2", "status":"qpi1_qpi_mc_st",     "addr":"qpi1_qpi_mc_ad",  "misc":"qpi1_qpi_mc_misc", "misc2":None},
           21:{"type":"uncore", "name":"QPI2", "ctl":"qpi2_qpi_mc_ctl", "ctl2":"qpi2_qpi_mc_ctl2", "status":"qpi2_qpi_mc_st",     "addr":"qpi2_qpi_mc_ad",  "misc":"qpi2_qpi_mc_misc", "misc2":None}}

#############################################################################
##Helper class for bit manipulation
# Usage: 
# v = BitVector(0xdeadbeef)
# v[3:0]  to read bit 0 to 3, return 0xf here
# v[3:0]=0x4  to write 0x4 to bit 0 to 3, replace 0xf to 0x4 here.
#
import math
class BitVector:
    def __init__(self,val):
        self._val = val

    def __setslice__(self,highIndx,lowIndx,newVal):
        assert math.ceil(math.log(newVal)/math.log(2)) <= (highIndx-lowIndx+1)

        # clear out bit slice
        clean_mask = (2**(highIndx+1)-1)^(2**(lowIndx)-1)

        self._val = self._val ^ (self._val & clean_mask)
        # set new value
        self._val = self._val | (newVal<<lowIndx)

    def __getslice__(self,highIndx,lowIndx):
        return (self._val>>lowIndx)&(2L**(highIndx-lowIndx+1)-1)

################################################################################################
class _mcaBankInfo():
    def __init__(self):
        self.bankNum       = 0 
        self.bankName      = ""
        self.sktNum        = 0
        self.coreNum       = 0
        self.ctl           = 0
        self.ctl2          = 0
        self.addr          = 0
        self.misc          = 0
        self.misc2         = 0
        self.status        = 0
        self.addr_shadow0  = 0
        self.addr_shadow1  = 0
        self.misc_shadow   = 0
        self.status_shadow = 0
        self.outInfotitle=""
        #self.outPutFile=""

#
# prototype decoder for mci_misc regs
# pass in bank num and reg value
#      
def _decodeMCAMiscReg(bank,misc):
    # Try a set of bank checks and direct code first
    # we may move to function calls for each misc bank.
    # may also want to move to banktype instead of bank number...more generic
    #
    vec_misc = BitVector(misc)
    if (bank == 0):
        # IFU
        print "  [8:6] ADDRESS_MODE     = 0x%x"%vec_misc[8:6]             
        print "  [5:0] IFU_ADDR_LSB     = 0x%x"%vec_misc[5:0]     
        #decodeCPUReg.WriteStrToFile(outPutFile, "  [8:6] ADDRESS_MODE     = 0x"+str(vec_misc[8:6]))
        #decodeCPUReg.WriteStrToFile(outPutFile, "  [5:0] IFU_ADDR_LSB     = 0x"+str(vec_misc[5:0]))
        
    elif (bank == 1):
        # DCU
        print "  [8:6] ADDRMODE     = 0x%x"%vec_misc[8:6]
        print "  [5:0] RECADDRLSB   = 0x%x"%vec_misc[5:0]
        #decodeCPUReg.WriteStrToFile(outPutFile, "  [8:6] ADDRMODE     = 0x"+str(vec_misc[8:6]))
        #decodeCPUReg.WriteStrToFile(outPutFile, "  [5:0] RECADDRLSB     = 0x"+str(vec_misc[5:0]))
    elif (bank == 3):
        # MLC
        print "  [63:24] ENHANCED MCA   = 0x%x"%vec_misc[63:24]
        print "  [23:23] THREAD         = 0x%x"%vec_misc[23:23]
        print "  [22:20] WAY            = 0x%x"%vec_misc[22:20]
        print "  [19:16] SQID           = 0x%x"%vec_misc[19:16]
        print "  [15:9] OPCODE          = 0x%x"%vec_misc[15:9]
        print "  [8:6] ADDRMODE         = 0x%x"%vec_misc[8:6]
        print "  [5:0] RECADDRLSB       = 0x%x"%vec_misc[5:0]
        #decodeCPUReg.WriteStrToFile(outPutFile, "  [63:24] ENHANCED MCA   = 0x"+str(vec_misc[63:24]))
        #decodeCPUReg.WriteStrToFile(outPutFile, "  [23:23] THREAD     = 0x"+str(vec_misc[23:23]))
        #decodeCPUReg.WriteStrToFile(outPutFile, "  [22:20] WAY     = 0x"+str(vec_misc[22:20]))
        #decodeCPUReg.WriteStrToFile(outPutFile, "  [19:16] SQID     = 0x"+str(vec_misc[19:16]))
        #decodeCPUReg.WriteStrToFile(outPutFile, "  [15:9] OPCODE     = 0x"+str(vec_misc[8:6]))
        #decodeCPUReg.WriteStrToFile(outPutFile, "  [8:6] ADDRMODE     = 0x"+str(vec_misc[23:23]))
        #decodeCPUReg.WriteStrToFile(outPutFile, "  [5:0] RECADDRLSB     = 0x"+str(vec_misc[5:0]))
    elif (bank == 4):
        # PCU
        print "  [23:16] CORRECTED_ERROR_COUNT  = 0x%x"%vec_misc[23:16]
        print "  [15:0]  ERROR_ADDRESS          = 0x%x"%vec_misc[15:0]
        
    elif (bank == 5):
        # QPI0 
        print "  [63:53] NERR               = 0x%x"%vec_misc[63:53]
        print "  [52:52] FLIT_VALID         = 0x%x"%vec_misc[52:52]
        print "  [51:32] FLIT_19_0          = 0x%x"%vec_misc[51:32]
        print "  [25:25] LLQUIESCE          = 0x%x"%vec_misc[25:25]
        print "  [24:24] GVRETRY            = 0x%x"%vec_misc[24:24]
        print "  [23:23] PHYRESET           = 0x%x"%vec_misc[23:23]
        print "  [21:21] EARLY_INJECT_ERR   = 0x%x"%vec_misc[21:21]
        print "  [20:20] FLIT_L_STATE       = 0x%x"%vec_misc[20:20]
        print "  [19:15] FLIT_39_35         = 0x%x"%vec_misc[19:15]
        print "  [14:6]  FLIT_28_20         = 0x%x"%vec_misc[14:6]
        print "  [5:5]   FLIT_58            = 0x%x"%vec_misc[5:5]
        print "  [4:3]   FLIT_41_40         = 0x%x"%vec_misc[4:3]
        print "  [2:1]   FLIT_61_60         = 0x%x"%vec_misc[2:1]
        print "  [0:0]   IIB                = 0x%x"%vec_misc[0:0]
    
    elif (bank == 6):
        # IIO
        print "  [39:32] UCR_SEGMENT_LOG        = 0x%x"%vec_misc[39:32]
        print "  [31:24] UCR_BUS_LOG            = 0x%x"%vec_misc[31:24]
        print "  [23:19] UCR_DEVICE_LOG         = 0x%x"%vec_misc[23:19]
        print "  [18:16] UCR_FUNCTION_LOG       = 0x%x"%vec_misc[18:16]
                
    elif (bank in range(7,9)):
        # HA (0-1)
        print "  [51:43] BTIDTO         = 0x%x"%vec_misc[51:43]
        print "  [42:42] MIRRORCORR     = 0x%x"%vec_misc[42:42]
        print "  [41:41] FAILOVER       = 0x%x"%vec_misc[41:41]
        print "  [40:39] HADBBANK       = 0x%x"%vec_misc[40:39]   
        print "  [38:37] PE             = 0x%x"%vec_misc[38:37]   
        print "  [34:29] REQOPCODE      = 0x%x"%vec_misc[34:29]   
        print "  [28:25] RNID           = 0x%x"%vec_misc[28:25]   
        print "  [22:17] RTID           = 0x%x"%vec_misc[22:17]   
        print "  [15:9]  HTID           = 0x%x"%vec_misc[15:9]   
        print "  [8:6]  ADDRMODE        = 0x%x"%vec_misc[8:6]   
        print "  [5:0]  ADDRLSB         = 0x%x"%vec_misc[5:0] 
        
    elif (bank in range(9,17)):
        # IMC (0-7)  
        print "  [63:63] Mode-2, second corr error valid = 0x%x"%vec_misc[63:63]
        print "  [62:62] Mode-2, first corr error valid = 0x%x"%vec_misc[62:62]
        print "  [61:59] Second Error Failing DIMM Slot = 0x%x"%vec_misc[61:59]
        print "  [58:56] First Error Failing DIMM Slot = 0x%x"%vec_misc[58:56]
        print "  [55:51] Second Error Failing Rank = 0x%x"%vec_misc[55:51]
        print "  [50:46] First Error Failing Rank  = 0x%x"%vec_misc[50:46]
        print "  [45:30] Second Error Bit Mask  = 0x%x"%vec_misc[45:30]
        print "  [29:14] First Error Bit Mask  = 0x%x"%vec_misc[29:14]
        print "  [13:9] WDB ID or second error device  = 0x%x"%vec_misc[13:9]
        print "  [8:6] ADDR_MODE = 0x%x"%vec_misc[8:6]
        print "  [5:0] REC_ERR_LSB = 0x%x"%vec_misc[5:0]
            
    elif (bank in range(17,20)):
        # Cbo/LLC
        print "  [63:58] RTID        = 0x%x"%vec_misc[63:58]
        # Decode origReq  - this is very useful for hang debug
        origReq = vec_misc[51:43] #_bits(misc,43,9)
        # check for the key and decode if we find one
        if (origReq in _cboTorOrigRequestDecode.keys()):
            print "  [51:43] OrigReq     = 0x%03x  => %s"%(origReq,_cboTorOrigRequestDecode[origReq])
        else:
            print "  [51:43] OrigReq     = 0x%03x"%origReq
        print "  [42:38] TORID      = 0x%x"%vec_misc[42:38]    

            
        print "  [28:24] COREID     = 0x%x"%vec_misc[28:24]
        print "  [23:23] THREADID   = 0x%x"%vec_misc[23:23]
        print "  [18:14] WAY        = 0x%x"%vec_misc[18:14]
        print "  [8:6] ADDRMODE     = 0x%x"%vec_misc[8:6]
        print "  [5:0] ADDRLSB      = 0x%x"%vec_misc[5:0]        

#Decode OrigReq values        
_cboTorOrigRequestDecode =  {  
        0x180: 'Request for Ownership',
        0x181: 'Code Read',
        0x182: 'Data Read',
        0x183: 'Set Monitor',
        0x186: 'Data Read',
        0x187: 'Partial Cacheline Read. Also used for PCIeCfgRd transaction',
        0x18C: 'Write Combine Invalidate Line',
        0x18D: 'Write Combine Invalidate Line',
        0x18E: 'Uncacheable Read',
        0x18F: 'Write Invalidate Line. Also used for PCIeCfgWr transaction',
        0x190: 'Prefetch - Request for Ownership',
        0x191: 'Prefetch Code',
        0x192: 'Prefetch Data',
        0x193: 'PCIe Request - Write invalidate line',
        0x194: 'PCIe Request - Write invalidate line',
        0x198: 'Cache Line Flush',
        #0x9B:  'LLC Victim (either EWB to memory or Evict Cache-line)', # Double check this value with Anil
        0x19C: 'PCIe Request - Invalid to Modify',
        0x19E: 'PCIe Request - Read Current',
        0x1C4: 'Write-back Modify to Invalid',
        0x1C5: 'Write-back Modify to Exclusive',
        0x1C8: 'Invalid to Modify Request',
        0x1E0: 'Special Cycle',
        0x1E1: 'PCIe Request - Direct Cache Access',
        0x1E4: 'PCIe Request - NonSnoop Read',
        0x1E5: 'PCIe Request - NonSnoop Read',
        0x1E6: 'PCIe Request - NonSnoop Read',
        0x1F3: 'Unlock',
        0x1F4: 'Interrupt Acknowledge',
        0x1F5: 'Port Out (CFC/CF8 type transaction',
        0x1F6: 'Floating Point Exception',
        0x1F8: 'End-of-level triggered Interrupt',
        0x1F9: 'Interrupt (logically addressed)',
        0x1FA: 'Interrupt (physically addressed)',
        0x1FB: 'Interrupt Priority Update',
        0x1FC: 'Port In (CFC/CF8 type transaction)',
        0x1FE: 'Split Lock',
        0x1FF: 'Lock',
        0x100: 'Snoop',
        0x101: 'Snoop',
        0x102: 'Snoop',
        0x104: 'Snoop',
        0x108: 'Snoop',
        0x10A: 'Snoop',
        0x10F: 'Snoop'}

#import decodeCPUReg
def _decodeMCABank(error):
    """
    One Machine Check Error per bank is recorded. However each bank can have multiple error bits set. 
    We shall consider each error bit set as an individual error and not a single error per bank.
    Corrected error count is printed separately

   """
   #print "_decodeMCABank input:", str(error.bankNum), str(error.status), str(error.addr), str(error.misc)
    # Doing this initial status check specifically for HA case, where perhaps status was 0x0 but status_shadow was valid
    vec_error_status = BitVector(error.status)
    if (vec_error_status[63:63]==1) or (vec_error_status[59:59]==1) or (vec_error_status[58:58]==1):
        print "\n-----------------------------------------------------------------------------------------------"
        print "####HSX#"+error.outInfotitle.strip('\n')+"####"
        #decodeCPUReg.WriteStrToFile(outPutFile, "-----------------------------------------------------------------------------------------------")
        #decodeCPUReg.WriteStrToFile(outPutFile, "####HSX#"+error.outInfotitle.strip('\n')+"####")
        #decodeCPUReg.WriteStrToFile(outPutFile, "MC_STATUS = "+str(hex(error.status))
        print "####BANK = "+str(error.bankNum)+"####"
        #decodeCPUReg.WriteStrToFile(outPutFile, "####BANK = "+str(error.bankNum)+"####")
        print "MC_STATUS = 0x%016X"%error.status
        #decodeCPUReg.WriteStrToFile(outPutFile, 
        (miscv, addrv) = _decodeMCStatus_simple(error.status)

        _MscodDebugAdvice(error.bankNum, error.status) 
        print
        if miscv:
            print "MC_MISC  = 0x%016X"%error.misc
            _decodeMCAMiscReg(error.bankNum, error.misc)
            print
            if (_mcRegs[error.bankNum]["misc2"] != None):
                print "MC_MISC2 = 0x%016X"%error.misc2
        if addrv:
            print "MC_ADDR  = 0x%016X"%error.addr
    #else:
    	#return -1
        #print
        #print "MC_STATUS = 0x%016X"%error.status
        #print "Not a valide MC_STATUS reg(MC_STATUS[63]=0), skipping MCA decoding...."

    if error.status_shadow==0:
    	return
    vec_error_stataus_shadow = BitVector(error.status_shadow)
    if (error.bankNum == 7) or (error.bankNum == 8):
        print
        print "####HSX#"+error.outInfotitle.strip('\n')+"####"
        print "####BANK = "+str(error.bankNum)+"####"
        print "MC_STATUS_SHADOW = 0x%016X"%error.status_shadow
        (miscv, addrv) = _decodeMCStatus_simple(error.status_shadow)
        print
        if vec_error_stataus_shadow[63:63]:
            _MscodDebugAdvice(error.bankNum, error.status_shadow) 
            print
        if miscv:
            print "MC_MISC_SHADOW = 0x%016X"%error.misc_shadow
            _decodeMCAMiscReg(error.bankNum, error.misc_shadow)
        if addrv:
            shadowAddr = (error.addr_shadow1 << 32) | error.addr_shadow0
            print "MC_ADDR_SHADOW = 0x%016X"%shadowAddr
    print
    #print "More detailed MCA Decode feature to be added later..."
    #print
# End _decodeMCABank()


def _findNonZeroLSB( numBits, value):
    #
    bitPos = 0
    # if we get a zero there is no lsb, return 0
    if (value == 0 or numBits == 0):
        return 0
    else:
        while (bitPos < numBits):
            # if we shift and the lsb is a 1, we are done
            if ((value >> bitPos) & 1) == 1:
                return bitPos
            else:
                bitPos = bitPos + 1
    
    return bitPos

def _MscodDebugAdvice(bank,status):
    vec_status = BitVector(status)
    mscod = vec_status[31:16]
    advisory_msg = ""
    advisory_msg_bank = 0
    bankName = ''
    if (bank == 0):
        bankName = 'IFU'
    elif (bank == 1):
        bankName = 'DCU'
    elif (bank == 2):
        bankName = 'DTLB'
    elif (bank == 3):
        bankName = 'MLC'
    elif (bank == 4):
        bankName = 'PCU'
    elif (bank == 5):
        bankName = 'QPI'
    elif (bank == 6):
        bankName = 'IO'
    elif (bank in range(7,8+1)):
        bankName = 'HA'
    elif (bank in range(9,16+1)):
        bankName = 'IMC'
    elif (bank in range(17,19+1)):
        bankName = 'Cbo/LLC'
    elif (bank in range(20,21+1)):
        bankName = 'QPI'

    # print 'Advice: %s' % bankName
    #
    # Loop through the decode list in the mca advice module
    # There are multiple pages for each bank type so there are two tiers
    # of this lookup process, the first is to find a match for bank type and then it is to see if 
    # the mask matches (andMask, orMask)
    #
    for item in _decodeList:
        # Find match for bankName
        if (item['bankType'] == bankName):
            # we have a bankType match, load the masks and see if there is a match
            # do an 'and' or 'or' mask of the status bits (mscod and mcacod) and see if we have a match.
            #print 'bankName Match'
            #print 'Status =%x : AndMask = %x : OrMask = %x' % (status, item['AndMask'], item['OrMask'])
            #print 'AndTestValue = %x  : OrTestValue = %x' % ((item['AndMask'] & status ), ( item['OrMask'] | status ))
            # we only check the mcacod value masks match (lowest 16 bits) 
            # if there are bits set (otherwise we only use mscod)
            if (item['AndMask'] & 0xffff == 0) or (item['OrMask'] & 0xffff == 0xffff):
                # we assume only one page (this one)
                # just extract the mscod value and check for a table entry.
                print '  MSCOD decode type title: %s' % (item['genDesc'])   
                # look up debug advice in the table of this 'item'
                #print '  Debug Advice:'
                # apply andmask and shift right 16 bits to normalize mscod value
                # if we find a key match, we print out the title (offset 0)
                # and debug advice (offset 1)
                # we could optimize this and pass in the offsets from the advice module...
                decodeKey = (status & item['fieldMask'] ) >> _findNonZeroLSB(64,item['fieldMask'])
                if (decodeKey in item['decode'].keys()):
                    print '  MSCOD Title: %s' % (item['decode'][decodeKey][0])
                    #decodeCPUReg.WriteStrToFile(outPutFile, "MSCOD Title: "+item['decode'][decodeKey][0])
                    msg = _textwrap.wrap(item['decode'][decodeKey][1], 90)
                    for line in range(len(msg)):
                        print "  %s"%msg[line]
                        #decodeCPUReg.WriteStrToFile(outPutFile, msg[line])
                else:
                    print 'No Advice found for this offset'                
                    #decodeCPUReg.WriteStrToFile(outPutFile, "No Advice found for this offset")
            else:
                # do full 'paging' check, that is check for match with entire mask (includes mcacod field)
                if ((item['AndMask'] & status == item['AndMask']) and ( item['OrMask'] | status == item['OrMask']) ) :
                    # we have a match
                    print '  MSCOD decode type title: %s' % (item['genDesc'])   
                    #decodeCPUReg.WriteStrToFile(outPutFile, " MSCOD decode type title: "+item['genDesc'])
                    # look up debug advice in the table of this 'item'
                    #print '  Debug Advice:'
                    # apply andmask and shift right 16 bits to normalize mscod value
                    # if we find a key match, we print out the title (offset 0)
                    # and debug advice (offset 1)
                    # we could optimize this and pass in the offsets from the advice module...
                    decodeKey = (status & item['fieldMask'] ) >> _findNonZeroLSB(64,item['fieldMask'])
                    if (decodeKey in item['decode'].keys()):
                        print '  MSCOD Title: %s' % (item['decode'][decodeKey][0])
                        #decodeCPUReg.WriteStrToFile(outPutFile, " MSCOD Title: "+item['decode'][decodeKey][0])
                        msg = _textwrap.wrap(item['decode'][decodeKey][1], 90)
                        for line in range(len(msg)):
                            print "  %s"%msg[line]
                            #decodeCPUReg.WriteStrToFile(outPutFile, msg[line])
                    else:
                        print 'No Advice found for this offset'
                        #decodeCPUReg.WriteStrToFile(outPutFile, "No Advice found for this offset")


def _decodeMCStatus_simple(status):
    miscv = 0
    addrv = 0
    vec_status = BitVector(status)
    if vec_status[63:63]:
        print "  [63] Valid"
        #decodeCPUReg.WriteStrToFile(outPutFile, " [63] Valid")
    #else:
        #print "  [63] Not valid"

    if vec_status[62:62]:
        print "  [62] Overflow"
        #decodeCPUReg.WriteStrToFile(outPutFile, " [62] Overflow")
    #else:
       # print "  [62] No overflow"
    if vec_status[61:61]:
        print "  [61] Uncorrected error"
        #decodeCPUReg.WriteStrToFile(outPutFile, " [61] Uncorrected error")
    #else:
        #print "  [61] Corrected error"
    if vec_status[60:60]:
        print "  [60] Enabled in MC_CTL"
        #decodeCPUReg.WriteStrToFile(outPutFile, " [60] Enabled in MC_CTL")
    #else:
        #print "  [60] Not enabled in MC_CTL"
    if vec_status[59:59]:
        print "  [59] MC_MISC is valid"
        #decodeCPUReg.WriteStrToFile(outPutFile, " [59] MC_MISC is valid")
        miscv = 1
    #else:
        #print "  [59] MC_MISC is not valid"
    if vec_status[58:58]:
        print "  [58] MC_ADDR is valid"
        #decodeCPUReg.WriteStrToFile(outPutFile, " [58] MC_ADDR is valid")
        addrv = 1
    #else:
        #print "  [58] MC_ADDR is not valid"
    if vec_status[57:57]:
        print "  [57] Processor context corrupt"
        #decodeCPUReg.WriteStrToFile(outPutFile, " [57] Processor context corrupt")
    #else:
        #print "  [57] Processor context is NOT corrupt"

    if vec_status[61:61] and not vec_status[57:57]:
        vFlag = True
    else:
        vFlag = False
        
    vStr=" "
    if not vFlag:
        print "  [56] (Not valid since error was correctable or processor context is corrupt)"
        #decodeCPUReg.WriteStrToFile(outPutFile, " [56] (Not valid since error was correctable or processor context is corrupt)")
    elif vec_status[56:56]:
        print "  [56] Signaled with MCERR %s"%vStr
        #decodeCPUReg.WriteStrToFile(outPutFile, " [56] Signaled with MCERR "+vStr)
    else:
        print "  [56] Signaled with CMCI %s"%vStr
        #decodeCPUReg.WriteStrToFile(outPutFile, " [56] Signaled with CMCI "+vStr)
    if not vFlag:
        print "  [55] (Not valid since error was correctable or processor context is corrupt)"
        #decodeCPUReg.WriteStrToFile(outPutFile, " [55] (Not valid since error was correctable or processor context is corrupt)")
    elif vec_status[55:55]:
        print "  [55] Action required %s"%vStr
        #decodeCPUReg.WriteStrToFile(outPutFile, " [55] Action required "+vStr)
    else:
        print "  [55] No action required %s"%vStr
        #decodeCPUReg.WriteStrToFile(outPutFile, " [55] No action required "+vStr)

    if vec_status[54:53] == 1:
        print "  [54:53] Corrected Error Status = Green"
        #decodeCPUReg.WriteStrToFile(outPutFile, " [54:53] Corrected Error Status = Green")
    elif vec_status[54:53] == 2:
        print "  [54:53] Corrected Error Status = Yellow"
        #decodeCPUReg.WriteStrToFile(outPutFile, " [54:53] Corrected Error Status = Yellow")

    print "  [52:38] Corrected Error Count = %d"%vec_status[52:38]
    #decodeCPUReg.WriteStrToFile(outPutFile, " [52:38] Corrected Error Count = "+str(vec_status[52:38]))
    print "  [37:32] Other Info = 0x%02x"%vec_status[37:32]
    #decodeCPUReg.WriteStrToFile(outPutFile, " [37:32] Other Info = "+str(vec_status[37:32]))
    print "  [31:16] MSCOD = 0x%04x"%vec_status[31:16]
    #decodeCPUReg.WriteStrToFile(outPutFile, " [31:16] MSCOD = "+str(vec_status[31:16]))
    print "  [15:0]  MCACOD = 0x%04x"%vec_status[15:0]
    #decodeCPUReg.WriteStrToFile(outPutFile, " [15:0]  MCACOD = "+str(vec_status[15:0]))
    return (miscv, addrv)
# End _decodeMCStatus_simple()


#########################################################
## Manual Decode block (get user inputs and decode them)
#########################################################
#
# ######################################################
# Name: getUserInput()
# Inputs:   None
# Output :  retList[] - True/False/'TestMode' (quit flag), bank, mcstatus, mcaddr, mcmisc
#

_menu = """
HSX-EP/EP 4S/EX Manual Machine Check Bank Decoder
Enter MCi_STATUS, MCi_ADDR, MCi_MISC values
RevString: %s
Enter 't' for a short demo
Enter 'Q' or 'q' to exit
"""%(_revString)

def _getUserInput():
    #
    # don't know how to return more than one item so we will pass a list
    retList = [False]
    reply = ''
    print _menu
    # Get Bank number
    tryAgain = True
    while tryAgain:
        reply = raw_input('Enter MCA Bank Name [0..31]:')
        if (reply == 'q' or reply == 'Q'):
            return(retList)
        # hook for test vector mode
        elif (reply == 't' or reply == 'T'):  # hook for test vector mode
            retList[0] = 'TestMode'
            return (retList)
        else:
            try:
                bank = int(reply)
                tryAgain = False
            except:
                print 'Incorrect number format, bank number is decimal only, please try again..'

    # Get MCi_STATUS
    tryAgain = True
    while tryAgain:
        reply = raw_input('Enter MCi_STATUS [0x0]: ')
        if (reply == 'q' or reply == 'Q'):
            return(retList)
        elif (reply == ''):
            mcstatus = 0
            tryAgain = False
        else:
            try:
                mcstatus = int(reply, 16)
                tryAgain = False
            except:
                print 'Incorrect number format: acceptable examples == [0xfe00000000800400 or fe00000000800400]'
    #
    # Get MCi_ADDR
    tryAgain = True
    while tryAgain:
        reply = raw_input('Enter MCi_ADDR   [0x0]: ')
        if (reply == 'q' or reply == 'Q'):
            return(retList)
        elif (reply == ''):
            mcaddr = 0
            tryAgain = False
        else:
            try:
                mcaddr = int(reply, 16)
                tryAgain = False
            except:
                print 'Incorrect number format: acceptable examples == [0xfe00000000800400 or fe00000000800400]'

    # Get MCi_MISC
    tryAgain = True
    while tryAgain:
        reply = raw_input('Enter MCi_MISC   [0x0]: ')
        if (reply == 'q' or reply == 'Q'):
            return(retList)
        elif (reply == ''):
            mcmisc = 0
            tryAgain = False
        else:
            try:
                mcmisc = int(reply, 16)
                tryAgain = False
            except:
                print 'Incorrect number format: acceptable examples == [0xfe00000000800400 or fe00000000800400]'

    # spacer for the output strings later
    print '\n\n'

    retList = [True, bank, mcstatus, mcaddr, mcmisc]
    return (retList)

#
#  Decode code is below
#
#
# ##########
# Name: bits()
#
# TODO : Remove if not used...
#
# The usual helper bits() function from ITP, returns a subset of the input register
# vector ased on the bit position and number of bits to return.
#
# def bits(inReg, bitPos, numBits):
    # bitMask = (2 ** numBits) -1
    # return ((inReg >> bitPos) & bitMask)


def _testVectors():

        print '\n\n***********************************************************************'
        print '\t\t\tTest Vectors \n'
        print '***********************************************************************\n'

        #MC1
        # bankNum   = 17
        # statusReg = 0xbe200000000c110a
        # miscReg   = 0xb0fff8160c400086
        # misc2Reg  = 0x0
        # addrReg   = 0x280
        # print 'basic first cut...'
        # ivtErrDump._decodeMCStatus_simple(statusReg)
        # ivtErrDump._MscodDebugAdvice(bankNum,statusReg)
        # print
        
                
        # define an mcabank object
        error = _mcaBankInfo()
        error.bankNum = 17
        error.bankName = 'Cbo/LLC'
        error.status = 0xbe200000000c110a
        error.misc = 0xb0fff8160c400086
        error.misc2 = 0x0
        error.addr = 0x280
        # stuff object into decoder
        _decodeMCABank(error)

        # define an mcabank object - this from mca on crb
        error = _mcaBankInfo()
        error.bankNum = 17
        error.bankName = 'Cbo/LLC'
        error.status = 0xBE200000000C110A
        error.misc = 0x70FC381600402086
        error.misc2 = 0x0
        error.addr = 0x0000000080500000
        # stuff object into decoder
        _decodeMCABank(error)


#
# This is the module entry point...
#
def manualDecode():

    """
    Decodes an MCA error and prints debug advice.

    Inputs:
    
        MCA Bank Name [0..31] 
        MCi_Status value 
        MCi_ADDR value  
        MCi_MISC value   
        
        
    Output: 
    
        Decoded MCA registers, and debug advice (if available)
    
    
    Example Usage: Decode an MCA Bank 5 (QPI0) Error 
    
    
        Enter MCA Bank Name [0..31]: 5
        Enter MCi_STATUS [0x0]: 0xC800014000310E0F
        Enter MCi_ADDR   [0x0]: 0x0
        Enter MCi_MISC   [0x0]: 0x001DF87B000D9EFF
        
        
        MC_STATUS = 0xC800014000310E0F
          [63] Valid
          [62] Overflow
          [61] Corrected error
          [60] Not enabled in MC_CTL
          [59] MC_MISC is valid
          [58] MC_ADDR is not valid
          [57] Processor context is NOT corrupt
          [56] (Not valid since error was correctable or processor context is corrupt)
          [55] (Not valid since error was correctable or processor context is corrupt)
          [52:38] Corrected Error Count = 5
          [37:32] Other Info = 0x00
          [31:16] MSCOD = 0x0031
          [15:0]  MCACOD = 0x0e0f

          MSCOD decode type title: QPI Errors
          MSCOD Title: QPI Error - Correctable: Tx CRC Error
          QPI Tx received a link level retry. This error is normally recommend to be disabled as it
          is a side effect of Rx CRC error on the other end of the QPI link. This is considered a
          temporary soft error type of event.

        MC_MISC  = 0x001DF87B000D9EFF
          [63:53] NERR               = 0x0
          [52:52] FLIT_VALID         = 0x1
          [51:32] FLIT_19_0          = 0xdf87b
          [25:25] LLQUIESCE          = 0x0
          [24:24] GVRETRY            = 0x0
          [23:23] PHYRESET           = 0x0
          [21:21] EARLY_INJECT_ERR   = 0x0
          [20:20] FLIT_L_STATE       = 0x0
          [19:15] FLIT_39_35         = 0x1b
          [14:6]  FLIT_28_20         = 0x7b
          [5:5]   FLIT_58            = 0x1
          [4:3]   FLIT_41_40         = 0x3
          [2:1]   FLIT_61_60         = 0x3
          [0:0]   IIB                = 0x1

    """
    
    try:
        #
        keepGoing = True
        bank =0
        statusReg = 0
        addressReg = 0
        miscReg = 0
        #
        # KeegGoing (get input/process input)
        # until user wants to quit
        while keepGoing:
            retList = _getUserInput()
            if (retList[0] == 'TestMode'):
                _testVectors()
                keepGoing = False
            else:
                keepGoing = retList[0]
            #
            # We got inputs, fill in the 
            # data structure and feed it to
            # the decoder module
            # This is done via manipulating a global list of errors
            #   1) append to the list (same as the dump logic would)
            #   2) call the decoder directly to work on the global
            #           
            if (keepGoing == True):
                # define an mcabank object
                error = _mcaBankInfo()
                error.bankNum = retList[1]
                error.status = retList[2]
                error.misc = retList[4]
                error.addr = retList[3]
                # stuff object into decoder
                _decodeMCABank(error)

    except:
        import traceback
        log = open('mca_decode.log', 'w')
        traceback.print_exc()
        traceback.print_exc(file=log)
        log.close()

def main():
    if len(sys.argv) == 1:  #run without any arguments
        manualDecode()
        return
        
    if len(sys.argv) != 5: #provide all 4 parameters
        print "Usage: mcd.py bank_num MCi_STATUS MCi_ADD MCi_MISC"
        sys.exit(2)
     
    #start the decoding
    error = _mcaBankInfo()
    error.bankNum = long(sys.argv[1], 16)
    error.status = long(sys.argv[2], 16)
    error.misc = long(sys.argv[4], 16)
    error.addr = long(sys.argv[3], 16)

    # stuff object into decoder
    _decodeMCABank(error)

if __name__ == "__main__":
    main()

